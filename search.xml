<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SpringCache整合Redis实现自定义缓存时间]]></title>
      <url>%2F201707%2FSpringCache%E6%95%B4%E5%90%88Redis%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4%2F</url>
      <content type="text"><![CDATA[Spring Cache简介Spring3.1开始引入了的基于注释(annotation)的缓存(cache)技术，它本质上不是一个具体的缓存实现方案，而是一个对缓存使用的抽象，通过在既有代码中添加注解，即能够达到缓存方法的返回对象的效果。 Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL 来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存例如 Redis 集成。 @Cacheable这个用的比较多，用在查询方法上，先从缓存中读取，如果缓存不存在再调用该方法获取数据，然后把返回的数据添加到缓存中去。1234@Cacheable(value = &quot;userCache&quot;, key = &quot;targetClass + &apos;.&apos; + methodName + &apos;.&apos; + &quot;#userid&quot;)public User getEntity(long userid) &#123; // 业务代码省略&#125; @CacheEvict清楚缓存1234@CacheEvict(value = &quot;userCache&quot;, key = &quot;targetClass + &apos;.&apos; + methodName + &apos;.&apos; + &quot;#userid&quot;)public boolean delete(long userid) &#123; // 业务代码省略&#125; @CachePut这个注释可以确保方法被执行，同时方法的返回值也被记录到缓存中，实现缓存与数据库的同步更新。1234@CachePut(value = &quot;userCache&quot;, key = &quot;targetClass + &apos;.&apos; + methodName + &apos;.&apos; + &quot;#user.getUserid&quot;)public User save(User user) &#123; // 业务代码省略&#125; 注：每个注解都有多个参数，这里不一一列出，建议进入源码查看注释。 缺点虽然Spring Cache用起来很方便的, 但不支持设置动态过期时间,这里需要重写RedisCacheManager的一些方法。 示例这里用的spring对redis的封装spring-data-redis，主要是对RedisCacheManager做一个二次封装。 导包12345678910&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 重写 RedisCacheManager1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.demo.cache;import java.util.Objects;import java.util.regex.Pattern;import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;import org.apache.commons.lang3.math.NumberUtils;import org.springframework.data.redis.cache.RedisCache;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.core.RedisOperations;import lombok.extern.log4j.Log4j2;/** * 重写redis缓存管理器 * &lt;p&gt; * 重写 RedisCacheManager createCache 方法 * &lt;p&gt; * 在缓存名字上添加过期时间表达式 如:cachename#60*60 * @author czk */@Log4j2public class ExtendedRedisCacheManager extends RedisCacheManager &#123; private static final ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName("JavaScript"); private static final Pattern pattern = Pattern.compile("[+\\-*/%]"); /** * 分隔符 */ private char separator = '#'; public ExtendedRedisCacheManager(@SuppressWarnings("rawtypes") RedisOperations redisOperations) &#123; super(redisOperations); &#125; @Override @SuppressWarnings("unchecked") protected RedisCache createCache(String cacheName) &#123; // 获取默认时间 long expiration = computeExpiration(cacheName); int index = cacheName.indexOf(this.getSeparator()); if (index &gt; 0) &#123; expiration = getExpiration(cacheName, index, expiration); &#125; return new RedisCache(cacheName, (isUsePrefix() ? getCachePrefix().prefix(cacheName) : null), getRedisOperations(), expiration); &#125; /** * 计算缓存时间 * @param name 缓存名字 cache#60*60 * @param separatorIndex 分隔符位置 * @param defalutExp 默认缓存时间 * @return */ protected long getExpiration(final String name, final int separatorIndex, final long defalutExp) &#123; Long expiration = null; String expirationAsString = name.substring(separatorIndex + 1); try &#123; if (pattern.matcher(expirationAsString).find()) &#123; expiration = NumberUtils.toLong(scriptEngine.eval(expirationAsString).toString(), defalutExp); &#125; else &#123; expiration = NumberUtils.toLong(expirationAsString, defalutExp); &#125; &#125; catch (ScriptException e) &#123; log.error("缓存时间转换错误:&#123;&#125;,异常:&#123;&#125;", name, e.getMessage()); &#125; return Objects.nonNull(expiration) ? expiration.longValue() : defalutExp; &#125; public char getSeparator() &#123; return separator; &#125; public void setSeparator(char separator) &#123; this.separator = separator; &#125;&#125; spring-redis.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.3.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:redis.properties&quot; /&gt; &lt;!-- 启用缓存注解功能,否则注解不会生效 --&gt; &lt;cache:annotation-driven cache-manager=&quot;cacheManager&quot; /&gt; &lt;!-- redis 相关配置 --&gt; &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot; /&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;$&#123;redis.maxWait&#125;&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;$&#123;redis.testOnBorrow&#125;&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; p:host-name=&quot;$&#123;redis.host&#125;&quot; p:port=&quot;$&#123;redis.port&#125;&quot; p:password=&quot;$&#123;redis.password&#125;&quot; p:database=&quot;$&#123;redis.database&#125;&quot; p:timeout=&quot;$&#123;redis.timeout&#125;&quot; p:pool-config-ref=&quot;poolConfig&quot; /&gt; &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt; &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot; /&gt; &lt;!--对key的序列化器 --&gt; &lt;property name=&quot;keySerializer&quot;&gt; &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt; &lt;/property&gt; &lt;!--是对value的列化器 默认:JdkSerializationRedisSerializer --&gt; &lt;property name=&quot;valueSerializer&quot;&gt; &lt;bean class=&quot;org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 扩展RedisCacheManager --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;com.demo.cache.ExtendedRedisCacheManager&quot;&gt; &lt;constructor-arg ref=&quot;redisTemplate&quot; /&gt; &lt;!-- 是否使用前缀 默认: --&gt; &lt;property name=&quot;usePrefix&quot; value=&quot;true&quot; /&gt; &lt;!-- 默认有效期1h (60 * 60 = 3600秒) --&gt; &lt;property name=&quot;defaultExpiration&quot; value=&quot;3600&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; redis.properties1234567891011121314#redis 缓存配置redis.host=127.0.0.1redis.port=6379redis.password=redis.database=0# 控制一个pool最多有多少个状态为idle(空闲的)的jedis实例 redis.maxIdle=300redis.maxctive=6000# 表示当borrow(引入)一个jedis实例时,最大的等待时间,如果超过等待时间(毫秒),则直接抛出JedisConnectionException； redis.maxWait=10000#在borrow一个jedis实例时,是否提前进行validate操作;如果为true,则得到的jedis实例均是可用的 redis.testOnBorrow=true#读超时时间redis.timeout=30000 注: Spring Cache是采用AOP来管理缓存，所有通过this调用的方法多不会触发缓存，key采用的是StringRedisSerializer序列化，所有key必须为String类型。 @Cacheable指定缓存5分钟1234@Cacheable(value = &quot;userCache#60*5&quot;, key = &quot;targetClass + &apos;.&apos; + methodName + &apos;.&apos; + &quot;#userid&quot;)public User getEntity(long userid) &#123; // 业务代码省略&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS安装JDK]]></title>
      <url>%2F201705%2FCentOS%E5%AE%89%E8%A3%85JDK%2F</url>
      <content type="text"><![CDATA[本想安安静静的做一个开发攻城狮的，但事与愿违，兼职干运维。身为一个Java攻城狮运维第一步必须要从装JDK开始。 源码包准备首先到官网下载jdk，我下载的是jdk-8u131-linux-x64.tar.gz，放到/usr/local/java目录下。 解压源码包1[root@localhost java]# tar xvf jdk-8u131-linux-x64.tar.gz 配置环境变量1[root@localhost java]# vim /etc/profile 找个空白地方添加配置:1234#java环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_131 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 保存退出，并运行source /etc/profile让配置生效1[root@localhost java]# source /etc/profile 验证输入java -version 如果出现下面的结果代表安装成功了1234[root@localhost java]# java -versionjava version &quot;1.8.0_131&quot; Java(TM) SE Runtime Environment (build 1.8.0_131-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 备注CentOS默认自带vi，功能没vim丰富，所以安装vim取代vi。1[root@localhost /]# yum -y install vim-enhanced 最后不要忘记删除jdk源码包，占空间1[root@localhost java]# rm jdk-8u131-linux-x64.tar.gz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringBoot之lombok]]></title>
      <url>%2F201704%2FSpringBoot%E4%B9%8Blombok%2F</url>
      <content type="text"><![CDATA[简介虽然Lombok也用到了注解，但是它并没有用到反射，而是通过一些奇淫巧技，在代码编译时期动态将注解替换为具体的代码。所以JVM实际运行的代码，和我们手动编写的包含了各种工具方法的类相同。 注解介绍 val - 终级解决方案！简化 final 局部变量定义。 @NonNull - 或者：了解我是怎样停止担心并爱上 NullPointerException 的。 @Cleanup - 怎么资源管理：方便而安全地调用 close() 方法。 @Getter / @Setter - 不再需要写像 public int getFoo() {return foo;} 这样的代码。 @ToString - 不用启动debug就能观察字段值：让 Lombok 为你生成 toString！ @EqualsAndHashCode - 让equal变得容易：在项目中由字段实现 hashCode 和 equals。 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor - 定制构造器：生成无参构造函数，对每个 final/非空 字段产生构造器，全参构造函数。 @Data - 它合并所有注解：相当于对所有字段应用 @ToString、@EqualsAndHashCode、@Getter，并对所有非 final 字段应用 @Setter，以及应用 @RequiredArgsConstructor！ @Value - 简单创意不可变类。 @Builder - … 一切都很简单：简单直接地创建对象的 API！ @SneakyThrows - 大胆的抛出以前不能轻易抛出的异常！ @Synchronized - 正确的同步：不要暴露你的锁。 @Getter(lazy=true) - 懒加载是种美德！ @Log - 打印log也是一种美德！ 安装IDEA安装lombok插件很简单File-&gt;Setting-&gt;Plugins-&gt;Browse repositories… 搜索lombok然后点击Install就OK了。 导包1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 接下就可以尽情体验lombok带来的便利了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringBoot之HelloWorld]]></title>
      <url>%2F201704%2FSpringBoot%E4%B9%8BHelloWorld%2F</url>
      <content type="text"><![CDATA[SpringBootSpring 框架作为目前非常流行的一个 Java 应用开发框架，它所包含的内容是非常繁多的。Spring 框架包含几十个不同的子项目，涵盖应用开发的不同方面。要在这些子项目之间进行选择，并快速搭建一个可以运行的应用是比较困难的事情。Spring Boot 的目的在于快速创建可以独立运行的 Spring 应用。通过 Spring Boot 可以根据相应的模板快速创建应用并运行。Spring Boot 可以自动配置 Spring 的各种组件，并不依赖代码生成和 XML 配置文件。Spring Boot 可以大大提升使用 Spring 框架时的开发效率。 中心思想约定优于配置 特点 创建独立的Spring应用程序 直接嵌入 Tomcat 或 Jetty 服务器，不需要部署 WAR 文件。 提供推荐的基础 POM 文件来简化 Maven 配置。 尽可能的根据项目依赖来自动配置 Spring 框架。 提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查。 没有代码生成，也没有 XML 配置文件。 写一个HelloWorld 创建一个maven项目 在pom.xml文件添加 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.springboot&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 创建程序入口 1234567891011121314151617181920package com.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@SpringBootApplicationpublic class Application &#123; @RequestMapping(&quot;/&quot;) String helloWorld() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 见证奇迹的时刻右击运行 Application 程序浏览器输入:http://localhost:8080 就会输出 Hello World!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse配置Maven仓库]]></title>
      <url>%2F201703%2FEclipse%E9%85%8D%E7%BD%AEMaven%E4%BB%93%E5%BA%93%2F</url>
      <content type="text"><![CDATA[WhyEclipse有自带Maven仓库,但它配置的国外的Maven仓库。平时下载jar包的速度实在是太慢,还经常下不成功, 所以想配一个国内的Maven库。 How下载从Apache官网下载最新版的Maven，并解压到安装目录。 配置配置阿里的Maven库, 配置settings.xml修改 conf 下的settings.xml:123456789101112131415161718192021222324252627282930313233&lt;localRepository&gt;E:/Repository&lt;/localRepository&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;Nexus aliyun&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Nexus aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;Nexus aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;Nexus aliyun&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 配置环境变量计算机右击属性-&gt;高级系统设置-&gt;环境变量在系统变量下的Path添加 D:\develop\apache-maven-3.3.9\bin; 配置Eclipse Window-&gt;Preferences-&gt;Maven-&gt;User Settings What 从此之后妈妈再也不用担心我下载jar慢啦！！！]]></content>
    </entry>

    
  
  
</search>
